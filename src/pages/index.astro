---
import Layout from '../layouts/Layout.astro';
import FV from '../components/sections/FV.astro';
import Problem from '../components/sections/Problem.astro';
import Solution from '../components/sections/Solution.astro';
import Features from '../components/sections/Features.astro';
import Ingenuity from '../components/sections/Ingenuity.astro';
import Reviews from '../components/sections/Reviews.astro';
import About from '../components/sections/About.astro';
import Caution from '../components/sections/Caution.astro';
import CTA from '../components/sections/CTA.astro';
import FAQ from '../components/sections/FAQ.astro';
---

<Layout title="メディコートアドバンス グレインフリー">
  <FV />
  <Problem />
  <Solution />
  <Features />
  <Ingenuity />
  <Reviews />
  <About />
  <Caution />
  <CTA />
  <FAQ />
</Layout>

<style is:global>
  /* ==========================================
     Carousel dot indicators
     ========================================== */
  .carousel-dots {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }

  .carousel-dots .dot {
    width: 8px;
    height: 8px;
    padding: 0;
    border: none;
    border-radius: 50%;
    background-color: #d9d9d9;
    cursor: pointer;
    transition: background-color 0.25s ease;
  }

  /* Active dot colors per section */
  .ingenuity .carousel-dots .dot.active,
  .reviews .carousel-dots .dot.active {
    background-color: #FF5100;
  }

  .caution .carousel-dots .dot.active {
    background-color: #81C776;
  }

  /* ==========================================
     Slider navigation buttons
     ========================================== */
  .slider-btn {
    padding: 0;
    border: none;
    background: none;
    cursor: pointer;
    line-height: 0;
    transition: transform 0.15s ease;
  }

  .slider-btn:active {
    transform: scale(0.85);
  }

  /* ==========================================
     Carousel card transition states
     ========================================== */

  /* All carousel cards: opacity-based visibility instead of display:none */
  [data-carousel-section] [class*="main_0"] {
    display: flex !important;
    opacity: 0;
    pointer-events: none;
    transition:
      transform 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94),
      opacity 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  /* Active (visible) card */
  [data-carousel-section] [class*="main_0"].carousel-active {
    opacity: 1;
    pointer-events: auto;
    z-index: 2;
  }

  /* Disable transition during finger drag */
  [data-carousel-section] [class*="main_0"].carousel-dragging {
    transition: none !important;
  }

  /* Adjacent cards (peek during drag) */
  [data-carousel-section] [class*="main_0"].carousel-adjacent {
    z-index: 1;
  }
</style>

<script>
  /* ============================================
     Carousel state
     ============================================ */
  interface CarouselState {
    current: number;
    total: number;
    dragging: boolean;
    startX: number;
    startY: number;
    startTime: number;
    currentTranslateX: number;
    directionLocked: null | 'horizontal' | 'vertical';
    scale: number;
  }

  const SWIPE_THRESHOLD = 60;
  const VELOCITY_THRESHOLD = 0.3;
  const DIRECTION_LOCK_DISTANCE = 5;
  const DIRECTION_LOCK_ANGLE = 30;
  const RUBBER_BAND_FACTOR = 0.3;
  const CARD_WIDTH = 326;
  const CARD_GAP = 16;
  const OFFSCREEN_OFFSET = CARD_WIDTH + CARD_GAP;

  interface CarouselDom {
    section: HTMLElement;
    screen: HTMLElement | null;
    cards: HTMLElement[];
    dots: HTMLElement | null;
  }

  const carousels: Record<string, CarouselState> = {
    feature: { current: 0, total: 3, dragging: false, startX: 0, startY: 0, startTime: 0, currentTranslateX: 0, directionLocked: null, scale: 1 },
    voice:   { current: 0, total: 4, dragging: false, startX: 0, startY: 0, startTime: 0, currentTranslateX: 0, directionLocked: null, scale: 1 },
    honesty: { current: 0, total: 3, dragging: false, startX: 0, startY: 0, startTime: 0, currentTranslateX: 0, directionLocked: null, scale: 1 },
  };
  const carouselDom: Record<string, CarouselDom> = {};
  const dragFrames: Record<string, number> = {};
  const dragDiffs: Record<string, number> = {};
  const initialized = new Set<string>();

  /* ============================================
     Scale factor helper
     ============================================ */
  function getScale(name: string): number {
    const screen = carouselDom[name]?.screen;
    if (!screen) return 1;
    const match = screen.style.transform.match(/scale\(([^)]+)\)/);
    return match ? parseFloat(match[1]) : 1;
  }

  /* ============================================
     Card element helpers
     ============================================ */
  function getCards(name: string): HTMLElement[] {
    return carouselDom[name]?.cards ?? [];
  }

  function getCardByIndex(name: string, index: number): HTMLElement | null {
    const cards = getCards(name);
    return cards[index] ?? null;
  }

  /* ============================================
     Dot indicator helpers
     ============================================ */
  function updateDots(name: string, index: number) {
    const dotsContainer = carouselDom[name]?.dots;
    if (!dotsContainer) return;
    dotsContainer.querySelectorAll('.dot').forEach((dot, i) => {
      dot.classList.toggle('active', i === index);
    });
  }

  function createDotsFor(name: string) {
    const dotsContainer = carouselDom[name]?.dots;
    if (!dotsContainer) return;
    if (dotsContainer.childElementCount > 0) return;

    const total = carousels[name].total;
    for (let i = 0; i < total; i++) {
      const dot = document.createElement('span');
      dot.className = 'dot' + (i === 0 ? ' active' : '');
      dot.dataset.index = String(i);
      dot.dataset.carousel = name;
      dot.setAttribute('aria-label', `スライド ${i + 1}`);

      dot.addEventListener('click', function (this: HTMLElement) {
        const n = this.dataset.carousel!;
        const idx = parseInt(this.dataset.index!, 10);
        if (!initialized.has(n)) initCarousel(n);
        showSlide(n, idx);
      });

      dotsContainer.appendChild(dot);
    }
  }

  function clearDraggingClasses(name: string) {
    getCards(name).forEach((card) => card.classList.remove('carousel-dragging'));
  }

  function applyDrag(name: string, designDiffX: number) {
    const state = carousels[name];
    const cards = getCards(name);
    if (!state || cards.length === 0) return;

    const total = state.total;
    const activeCard = cards[state.current];
    const prevCard = cards[(state.current - 1 + total) % total];
    const nextCard = cards[(state.current + 1) % total];

    if (activeCard) {
      activeCard.style.transform = `translateX(${designDiffX}px)`;
    }

    const setAdjacent = (card: HTMLElement | undefined, offset: number, progress: number) => {
      if (!card) return;
      card.classList.add('carousel-adjacent');
      card.style.opacity = String(Math.max(0.3, progress));
      card.style.transform = `translateX(${offset}px)`;
    };

    if (designDiffX < 0) {
      const progress = Math.min(1, Math.abs(designDiffX) / SWIPE_THRESHOLD);
      setAdjacent(nextCard, OFFSCREEN_OFFSET + designDiffX, progress);
      if (prevCard) {
        prevCard.style.opacity = '';
        prevCard.style.transform = `translateX(-${OFFSCREEN_OFFSET}px)`;
      }
    } else if (designDiffX > 0) {
      const progress = Math.min(1, Math.abs(designDiffX) / SWIPE_THRESHOLD);
      setAdjacent(prevCard, -OFFSCREEN_OFFSET + designDiffX, progress);
      if (nextCard) {
        nextCard.style.opacity = '';
        nextCard.style.transform = `translateX(${OFFSCREEN_OFFSET}px)`;
      }
    } else {
      if (prevCard) {
        prevCard.style.opacity = '';
        prevCard.style.transform = `translateX(-${OFFSCREEN_OFFSET}px)`;
      }
      if (nextCard) {
        nextCard.style.opacity = '';
        nextCard.style.transform = `translateX(${OFFSCREEN_OFFSET}px)`;
      }
    }
  }

  function scheduleDrag(name: string, designDiffX: number) {
    dragDiffs[name] = designDiffX;
    if (dragFrames[name]) return;
    dragFrames[name] = requestAnimationFrame(() => {
      dragFrames[name] = 0;
      const diff = dragDiffs[name];
      if (diff === undefined) return;
      applyDrag(name, diff);
    });
  }

  /* ============================================
     Slide navigation (class + translateX based)
     ============================================ */
  function showSlide(name: string, index: number) {
    const carousel = carousels[name];
    if (!carousel) return;

    // Wrap around at boundaries (infinite loop)
    index = ((index % carousel.total) + carousel.total) % carousel.total;
    carousel.current = index;

    const total = carousel.total;
    const prevIndex = (index - 1 + total) % total;
    const nextIndex = (index + 1) % total;

    const cards = getCards(name);
    cards.forEach((card, i) => {
      // Reset inline styles from drag
      card.style.transform = '';
      card.style.opacity = '';

      // Remove all state classes
      card.classList.remove('carousel-active', 'carousel-adjacent', 'carousel-dragging');

      if (i === index) {
        card.classList.add('carousel-active');
        card.style.transform = 'translateX(0)';
      } else if (i === prevIndex) {
        card.classList.add('carousel-adjacent');
        card.style.transform = `translateX(-${OFFSCREEN_OFFSET}px)`;
      } else if (i === nextIndex) {
        card.classList.add('carousel-adjacent');
        card.style.transform = `translateX(${OFFSCREEN_OFFSET}px)`;
      } else {
        card.style.transform = `translateX(${OFFSCREEN_OFFSET}px)`;
      }
    });

    updateDots(name, index);
  }

  /* ============================================
     Button click handling (prev/next)
     ============================================ */
  document.addEventListener('click', (e) => {
    const btn = (e.target as HTMLElement).closest(
      '.slider-btn, .reviews__slider-prev, .reviews__slider-next'
    );
    if (!btn) return;

    const name = (btn as HTMLElement).dataset.carousel;
    if (!name || !carousels[name]) return;

    const isPrev = btn.classList.contains('slider-btn--prev')
      || btn.classList.contains('reviews__slider-prev');
    const direction = isPrev ? -1 : 1;

    if (!initialized.has(name)) initCarousel(name);
    showSlide(name, carousels[name].current + direction);
  });

  /* ============================================
     Touch drag support (real-time tracking)
     ============================================ */
  function initDragFor(name: string) {
      const container = carouselDom[name]?.section;
      if (!container) return;

      /* ---------- touchstart ---------- */
      container.addEventListener('touchstart', ((e: TouchEvent) => {
        const state = carousels[name];
        state.dragging = true;
        state.startX = e.touches[0].clientX;
        state.startY = e.touches[0].clientY;
        state.startTime = Date.now();
        state.currentTranslateX = 0;
        state.directionLocked = null;
        state.scale = getScale(name);

        // Disable transition on current + adjacent cards for instant tracking
        const total = state.total;
        const activeCard = getCardByIndex(name, state.current);
        if (activeCard) activeCard.classList.add('carousel-dragging');
        const prevCard = getCardByIndex(name, (state.current - 1 + total) % total);
        if (prevCard) prevCard.classList.add('carousel-dragging');
        const nextCard = getCardByIndex(name, (state.current + 1) % total);
        if (nextCard) nextCard.classList.add('carousel-dragging');
      }) as EventListener, { passive: true });

      /* ---------- touchmove ---------- */
      container.addEventListener('touchmove', ((e: TouchEvent) => {
        const state = carousels[name];
        if (!state.dragging) return;

        const currentX = e.touches[0].clientX;
        const currentY = e.touches[0].clientY;
        const rawDiffX = currentX - state.startX;
        const rawDiffY = currentY - state.startY;

        // Direction lock: decide once
        if (state.directionLocked === null
            && (Math.abs(rawDiffX) > DIRECTION_LOCK_DISTANCE || Math.abs(rawDiffY) > DIRECTION_LOCK_DISTANCE)) {
          const angle = Math.abs(Math.atan2(rawDiffY, rawDiffX) * 180 / Math.PI);
          if (angle < DIRECTION_LOCK_ANGLE || angle > (180 - DIRECTION_LOCK_ANGLE)) {
            state.directionLocked = 'horizontal';
          } else {
            state.directionLocked = 'vertical';
            state.dragging = false;
            clearDraggingClasses(name);
            return;
          }
        }

        if (state.directionLocked !== 'horizontal') return;

        // Prevent vertical scroll while dragging horizontally
        e.preventDefault();

        // Convert screen px to design-space px
        const designDiffX = rawDiffX / state.scale;

        state.currentTranslateX = designDiffX;
        scheduleDrag(name, designDiffX);
      }) as EventListener, { passive: false });

      /* ---------- touchend ---------- */
      container.addEventListener('touchend', ((e: TouchEvent) => {
        const state = carousels[name];
        if (!state.dragging && state.directionLocked !== 'horizontal') return;
        state.dragging = false;

        // Re-enable transitions for snap animation
        clearDraggingClasses(name);

        const endX = e.changedTouches[0].clientX;
        const rawDiffX = endX - state.startX;
        const designDiffX = rawDiffX / state.scale;
        const elapsed = Date.now() - state.startTime;
        const velocity = elapsed > 0 ? Math.abs(designDiffX) / elapsed : 0;

        let newIndex = state.current;

        if (Math.abs(designDiffX) > SWIPE_THRESHOLD || velocity > VELOCITY_THRESHOLD) {
          if (designDiffX < 0) {
            newIndex = state.current + 1; // wraps via showSlide
          } else if (designDiffX > 0) {
            newIndex = state.current - 1; // wraps via showSlide
          }
        }

        // Snap to new index (or bounce back) with CSS transition
        showSlide(name, newIndex);
        state.directionLocked = null;
      }) as EventListener, { passive: true });
  }

  function initCarousel(name: string) {
    if (initialized.has(name)) return;
    if (!carouselDom[name]) return;
    createDotsFor(name);
    showSlide(name, 0);
    initDragFor(name);
    initialized.add(name);
  }

  /* ============================================
     Initialization
     ============================================ */
  document.addEventListener('DOMContentLoaded', () => {
    Object.keys(carousels).forEach((name) => {
      const section = document.querySelector(
        `[data-carousel-section="${name}"]`
      ) as HTMLElement | null;
      if (!section) return;
      const cards = Array.from(section.querySelectorAll<HTMLElement>('[class*="main_0"]'));
      const dots = document.querySelector(
        `.carousel-dots[data-carousel="${name}"]`
      ) as HTMLElement | null;
      const screen = section.closest('.screen') as HTMLElement | null;
      carouselDom[name] = { section, screen, cards, dots };
    });

    const root = document.querySelector('.lp-container') as HTMLElement | null;
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) return;
        const section = entry.target as HTMLElement;
        const name = section.dataset.carouselSection;
        if (!name) return;
        initCarousel(name);
        observer.unobserve(section);
      });
    }, { root, rootMargin: '120px 0px' });

    Object.keys(carousels).forEach((name) => {
      const section = carouselDom[name]?.section;
      if (section) observer.observe(section);
    });
  });
</script>
